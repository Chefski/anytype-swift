// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vendor/github.com/anytypeio/go-anytype-library/pb/model/protos/models.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Anytype_Model_Block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var fields: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._fields ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._fields = newValue}
  }
  /// Returns true if `fields` has been explicitly set.
  var hasFields: Bool {return _storage._fields != nil}
  /// Clears the value of `fields`. Subsequent reads from it will return its default value.
  mutating func clearFields() {_uniqueStorage()._fields = nil}

  var restrictions: Anytype_Model_Block.Restrictions {
    get {return _storage._restrictions ?? Anytype_Model_Block.Restrictions()}
    set {_uniqueStorage()._restrictions = newValue}
  }
  /// Returns true if `restrictions` has been explicitly set.
  var hasRestrictions: Bool {return _storage._restrictions != nil}
  /// Clears the value of `restrictions`. Subsequent reads from it will return its default value.
  mutating func clearRestrictions() {_uniqueStorage()._restrictions = nil}

  var childrenIds: [String] {
    get {return _storage._childrenIds}
    set {_uniqueStorage()._childrenIds = newValue}
  }

  var isArchived: Bool {
    get {return _storage._isArchived}
    set {_uniqueStorage()._isArchived = newValue}
  }

  var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  var dashboard: Anytype_Model_Block.Content.Dashboard {
    get {
      if case .dashboard(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Dashboard()
    }
    set {_uniqueStorage()._content = .dashboard(newValue)}
  }

  var page: Anytype_Model_Block.Content.Page {
    get {
      if case .page(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Page()
    }
    set {_uniqueStorage()._content = .page(newValue)}
  }

  var dataview: Anytype_Model_Block.Content.Dataview {
    get {
      if case .dataview(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Dataview()
    }
    set {_uniqueStorage()._content = .dataview(newValue)}
  }

  var text: Anytype_Model_Block.Content.Text {
    get {
      if case .text(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Text()
    }
    set {_uniqueStorage()._content = .text(newValue)}
  }

  var file: Anytype_Model_Block.Content.File {
    get {
      if case .file(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.File()
    }
    set {_uniqueStorage()._content = .file(newValue)}
  }

  var layout: Anytype_Model_Block.Content.Layout {
    get {
      if case .layout(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Layout()
    }
    set {_uniqueStorage()._content = .layout(newValue)}
  }

  var div: Anytype_Model_Block.Content.Div {
    get {
      if case .div(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Div()
    }
    set {_uniqueStorage()._content = .div(newValue)}
  }

  var bookmark: Anytype_Model_Block.Content.Bookmark {
    get {
      if case .bookmark(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Bookmark()
    }
    set {_uniqueStorage()._content = .bookmark(newValue)}
  }

  var icon: Anytype_Model_Block.Content.Icon {
    get {
      if case .icon(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Icon()
    }
    set {_uniqueStorage()._content = .icon(newValue)}
  }

  var link: Anytype_Model_Block.Content.Link {
    get {
      if case .link(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Link()
    }
    set {_uniqueStorage()._content = .link(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case dashboard(Anytype_Model_Block.Content.Dashboard)
    case page(Anytype_Model_Block.Content.Page)
    case dataview(Anytype_Model_Block.Content.Dataview)
    case text(Anytype_Model_Block.Content.Text)
    case file(Anytype_Model_Block.Content.File)
    case layout(Anytype_Model_Block.Content.Layout)
    case div(Anytype_Model_Block.Content.Div)
    case bookmark(Anytype_Model_Block.Content.Bookmark)
    case icon(Anytype_Model_Block.Content.Icon)
    case link(Anytype_Model_Block.Content.Link)

  #if !swift(>=4.1)
    static func ==(lhs: Anytype_Model_Block.OneOf_Content, rhs: Anytype_Model_Block.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.dashboard(let l), .dashboard(let r)): return l == r
      case (.page(let l), .page(let r)): return l == r
      case (.dataview(let l), .dataview(let r)): return l == r
      case (.text(let l), .text(let r)): return l == r
      case (.file(let l), .file(let r)): return l == r
      case (.layout(let l), .layout(let r)): return l == r
      case (.div(let l), .div(let r)): return l == r
      case (.bookmark(let l), .bookmark(let r)): return l == r
      case (.icon(let l), .icon(let r)): return l == r
      case (.link(let l), .link(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  enum Position: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case top // = 1
    case bottom // = 2
    case left // = 3
    case right // = 4
    case inner // = 5
    case replace // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .top
      case 2: self = .bottom
      case 3: self = .left
      case 4: self = .right
      case 5: self = .inner
      case 6: self = .replace
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .top: return 1
      case .bottom: return 2
      case .left: return 3
      case .right: return 4
      case .inner: return 5
      case .replace: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct Restrictions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var read: Bool = false

    var edit: Bool = false

    var remove: Bool = false

    var drag: Bool = false

    var dropOn: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Content {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// Layout have no visual representation, but affects on blocks, that it contains.
    /// Row/Column layout blocks creates only automatically, after some of a D&D operations, for example
    struct Layout {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var style: Anytype_Model_Block.Content.Layout.Style = .row

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Style: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case row // = 0
        case column // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .row
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .row
          case 1: self = .column
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .row: return 0
          case .column: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}
    }

    ///
    /// Link: block to link some content from an external sources.
    struct Link {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// id of the target block
      var targetBlockID: String {
        get {return _storage._targetBlockID}
        set {_uniqueStorage()._targetBlockID = newValue}
      }

      var style: Anytype_Model_Block.Content.Link.Style {
        get {return _storage._style}
        set {_uniqueStorage()._style = newValue}
      }

      var fields: SwiftProtobuf.Google_Protobuf_Struct {
        get {return _storage._fields ?? SwiftProtobuf.Google_Protobuf_Struct()}
        set {_uniqueStorage()._fields = newValue}
      }
      /// Returns true if `fields` has been explicitly set.
      var hasFields: Bool {return _storage._fields != nil}
      /// Clears the value of `fields`. Subsequent reads from it will return its default value.
      mutating func clearFields() {_uniqueStorage()._fields = nil}

      var isArchived: Bool {
        get {return _storage._isArchived}
        set {_uniqueStorage()._isArchived = newValue}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Style: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case page // = 0
        case dataview // = 1

        /// ...
        case dashboard // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .page
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .page
          case 1: self = .dataview
          case 2: self = .dashboard
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .page: return 0
          case .dataview: return 1
          case .dashboard: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    ///
    /// Divider: block, that contains only one horizontal thin line
    struct Div {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var style: Anytype_Model_Block.Content.Div.Style = .line

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Style: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case line // = 0
        case dots // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .line
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .line
          case 1: self = .dots
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .line: return 0
          case .dots: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}
    }

    ///
    /// Bookmark is to keep a web-link and to preview a content.
    struct Bookmark {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Icon {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    ///
    /// Block type to organize pages on the main screen (main purpose)
    /// It also can be mounted on a page.
    struct Dashboard {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var style: Anytype_Model_Block.Content.Dashboard.Style = .mainScreen

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Style: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case mainScreen // = 0
        case archive // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .mainScreen
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .mainScreen
          case 1: self = .archive
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .mainScreen: return 0
          case .archive: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}
    }

    struct Dataview {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Text {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var text: String {
        get {return _storage._text}
        set {_uniqueStorage()._text = newValue}
      }

      var style: Anytype_Model_Block.Content.Text.Style {
        get {return _storage._style}
        set {_uniqueStorage()._style = newValue}
      }

      /// list of marks to apply to the text
      var marks: Anytype_Model_Block.Content.Text.Marks {
        get {return _storage._marks ?? Anytype_Model_Block.Content.Text.Marks()}
        set {_uniqueStorage()._marks = newValue}
      }
      /// Returns true if `marks` has been explicitly set.
      var hasMarks: Bool {return _storage._marks != nil}
      /// Clears the value of `marks`. Subsequent reads from it will return its default value.
      mutating func clearMarks() {_uniqueStorage()._marks = nil}

      var checked: Bool {
        get {return _storage._checked}
        set {_uniqueStorage()._checked = newValue}
      }

      var color: String {
        get {return _storage._color}
        set {_uniqueStorage()._color = newValue}
      }

      var backgroundColor: String {
        get {return _storage._backgroundColor}
        set {_uniqueStorage()._backgroundColor = newValue}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Style: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case paragraph // = 0
        case header1 // = 1
        case header2 // = 2
        case header3 // = 3
        case header4 // = 4
        case quote // = 5
        case code // = 6
        case title // = 7
        case checkbox // = 8
        case marked // = 9
        case numbered // = 10
        case toggle // = 11
        case UNRECOGNIZED(Int)

        init() {
          self = .paragraph
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .paragraph
          case 1: self = .header1
          case 2: self = .header2
          case 3: self = .header3
          case 4: self = .header4
          case 5: self = .quote
          case 6: self = .code
          case 7: self = .title
          case 8: self = .checkbox
          case 9: self = .marked
          case 10: self = .numbered
          case 11: self = .toggle
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .paragraph: return 0
          case .header1: return 1
          case .header2: return 2
          case .header3: return 3
          case .header4: return 4
          case .quote: return 5
          case .code: return 6
          case .title: return 7
          case .checkbox: return 8
          case .marked: return 9
          case .numbered: return 10
          case .toggle: return 11
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      struct Marks {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var marks: [Anytype_Model_Block.Content.Text.Mark] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Mark {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// range of symbols to apply this mark. From(symbol) To(symbol)
        var range: Anytype_Model_Range {
          get {return _storage._range ?? Anytype_Model_Range()}
          set {_uniqueStorage()._range = newValue}
        }
        /// Returns true if `range` has been explicitly set.
        var hasRange: Bool {return _storage._range != nil}
        /// Clears the value of `range`. Subsequent reads from it will return its default value.
        mutating func clearRange() {_uniqueStorage()._range = nil}

        var type: Anytype_Model_Block.Content.Text.Mark.TypeEnum {
          get {return _storage._type}
          set {_uniqueStorage()._type = newValue}
        }

        /// link, color, etc
        var param: String {
          get {return _storage._param}
          set {_uniqueStorage()._param = newValue}
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum TypeEnum: SwiftProtobuf.Enum {
          typealias RawValue = Int
          case strikethrough // = 0
          case keyboard // = 1
          case italic // = 2
          case bold // = 3
          case underscored // = 4
          case link // = 5
          case textColor // = 6
          case backgroundColor // = 7
          case UNRECOGNIZED(Int)

          init() {
            self = .strikethrough
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .strikethrough
            case 1: self = .keyboard
            case 2: self = .italic
            case 3: self = .bold
            case 4: self = .underscored
            case 5: self = .link
            case 6: self = .textColor
            case 7: self = .backgroundColor
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .strikethrough: return 0
            case .keyboard: return 1
            case .italic: return 2
            case .bold: return 3
            case .underscored: return 4
            case .link: return 5
            case .textColor: return 6
            case .backgroundColor: return 7
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
      }

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct File {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var hash: String = String()

      var name: String = String()

      var type: Anytype_Model_Block.Content.File.TypeEnum = .none

      var mime: String = String()

      var size: Int64 = 0

      var addedAt: Int64 = 0

      var state: Anytype_Model_Block.Content.File.State = .empty

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TypeEnum: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case none // = 0
        case file // = 1
        case image // = 2
        case video // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .none
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .file
          case 2: self = .image
          case 3: self = .video
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .none: return 0
          case .file: return 1
          case .image: return 2
          case .video: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      enum State: SwiftProtobuf.Enum {
        typealias RawValue = Int

        /// There is no file and preview, it's an empty block, that waits files.
        case empty // = 0

        /// There is still no file/preview, but file already uploading
        case uploading // = 1

        /// File and preview downloaded
        case done // = 2

        /// Error while uploading
        case error // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .empty
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .empty
          case 1: self = .uploading
          case 2: self = .done
          case 3: self = .error
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .empty: return 0
          case .uploading: return 1
          case .done: return 2
          case .error: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}
    }

    struct Page {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var style: Anytype_Model_Block.Content.Page.Style = .empty

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Style: SwiftProtobuf.Enum {
        typealias RawValue = Int

        /// Ordinary page, without additional fields
        case empty // = 0

        /// Page with a task fields
        case task // = 1

        /// Page, that organize a set of blocks by a specific criterio
        case set // = 2

        /// ...
        case breadcrumbs // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .empty
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .empty
          case 1: self = .task
          case 2: self = .set
          case 3: self = .breadcrumbs
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .empty: return 0
          case .task: return 1
          case .set: return 2
          case .breadcrumbs: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Anytype_Model_Block.Position: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Anytype_Model_Block.Position] = [
    .none,
    .top,
    .bottom,
    .left,
    .right,
    .inner,
    .replace,
  ]
}

#endif  // swift(>=4.2)

///
/// Used to decode block meta only, without the content itself
struct Anytype_Model_BlockMetaOnly {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var fields: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._fields ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._fields = newValue}
  }
  /// Returns true if `fields` has been explicitly set.
  var hasFields: Bool {return _storage._fields != nil}
  /// Clears the value of `fields`. Subsequent reads from it will return its default value.
  mutating func clearFields() {_uniqueStorage()._fields = nil}

  var isArchived: Bool {
    get {return _storage._isArchived}
    set {_uniqueStorage()._isArchived = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// General purpose structure, uses in Mark.
struct Anytype_Model_Range {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var from: Int32 = 0

  var to: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Contains basic information about a user account
struct Anytype_Model_Account {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User's thread id
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// User name, that associated with this account
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Avatar of a user's account
  var avatar: Anytype_Model_Account.Avatar {
    get {return _storage._avatar ?? Anytype_Model_Account.Avatar()}
    set {_uniqueStorage()._avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  var hasAvatar: Bool {return _storage._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  mutating func clearAvatar() {_uniqueStorage()._avatar = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// Avatar of a user's account. It could be an image or color
  struct Avatar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var avatar: OneOf_Avatar? {
      get {return _storage._avatar}
      set {_uniqueStorage()._avatar = newValue}
    }

    /// Image of the avatar. Contains the hash to retrieve the image.
    var image: Anytype_Model_Block.Content.File {
      get {
        if case .image(let v)? = _storage._avatar {return v}
        return Anytype_Model_Block.Content.File()
      }
      set {_uniqueStorage()._avatar = .image(newValue)}
    }

    /// Color of the avatar, used if image not set.
    var color: String {
      get {
        if case .color(let v)? = _storage._avatar {return v}
        return String()
      }
      set {_uniqueStorage()._avatar = .color(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Avatar: Equatable {
      /// Image of the avatar. Contains the hash to retrieve the image.
      case image(Anytype_Model_Block.Content.File)
      /// Color of the avatar, used if image not set.
      case color(String)

    #if !swift(>=4.1)
      static func ==(lhs: Anytype_Model_Account.Avatar.OneOf_Avatar, rhs: Anytype_Model_Account.Avatar.OneOf_Avatar) -> Bool {
        switch (lhs, rhs) {
        case (.image(let l), .image(let r)): return l == r
        case (.color(let l), .color(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "anytype.model"

extension Anytype_Model_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Block"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "fields"),
    3: .same(proto: "restrictions"),
    4: .same(proto: "childrenIds"),
    5: .same(proto: "isArchived"),
    11: .same(proto: "dashboard"),
    12: .same(proto: "page"),
    13: .same(proto: "dataview"),
    14: .same(proto: "text"),
    15: .same(proto: "file"),
    16: .same(proto: "layout"),
    17: .same(proto: "div"),
    18: .same(proto: "bookmark"),
    19: .same(proto: "icon"),
    20: .same(proto: "link"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _fields: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _restrictions: Anytype_Model_Block.Restrictions? = nil
    var _childrenIds: [String] = []
    var _isArchived: Bool = false
    var _content: Anytype_Model_Block.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _fields = source._fields
      _restrictions = source._restrictions
      _childrenIds = source._childrenIds
      _isArchived = source._isArchived
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._fields)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._restrictions)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._childrenIds)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._isArchived)
        case 11:
          var v: Anytype_Model_Block.Content.Dashboard?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .dashboard(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .dashboard(v)}
        case 12:
          var v: Anytype_Model_Block.Content.Page?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .page(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .page(v)}
        case 13:
          var v: Anytype_Model_Block.Content.Dataview?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .dataview(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .dataview(v)}
        case 14:
          var v: Anytype_Model_Block.Content.Text?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .text(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .text(v)}
        case 15:
          var v: Anytype_Model_Block.Content.File?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .file(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .file(v)}
        case 16:
          var v: Anytype_Model_Block.Content.Layout?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .layout(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .layout(v)}
        case 17:
          var v: Anytype_Model_Block.Content.Div?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .div(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .div(v)}
        case 18:
          var v: Anytype_Model_Block.Content.Bookmark?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .bookmark(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .bookmark(v)}
        case 19:
          var v: Anytype_Model_Block.Content.Icon?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .icon(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .icon(v)}
        case 20:
          var v: Anytype_Model_Block.Content.Link?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .link(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .link(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._fields {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._restrictions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._childrenIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._childrenIds, fieldNumber: 4)
      }
      if _storage._isArchived != false {
        try visitor.visitSingularBoolField(value: _storage._isArchived, fieldNumber: 5)
      }
      switch _storage._content {
      case .dashboard(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .page(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .dataview(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .text(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .file(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .layout(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .div(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .bookmark(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .icon(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .link(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block, rhs: Anytype_Model_Block) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._fields != rhs_storage._fields {return false}
        if _storage._restrictions != rhs_storage._restrictions {return false}
        if _storage._childrenIds != rhs_storage._childrenIds {return false}
        if _storage._isArchived != rhs_storage._isArchived {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Position: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "Top"),
    2: .same(proto: "Bottom"),
    3: .same(proto: "Left"),
    4: .same(proto: "Right"),
    5: .same(proto: "Inner"),
    6: .same(proto: "Replace"),
  ]
}

extension Anytype_Model_Block.Restrictions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.protoMessageName + ".Restrictions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "read"),
    2: .same(proto: "edit"),
    3: .same(proto: "remove"),
    4: .same(proto: "drag"),
    5: .same(proto: "dropOn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.read)
      case 2: try decoder.decodeSingularBoolField(value: &self.edit)
      case 3: try decoder.decodeSingularBoolField(value: &self.remove)
      case 4: try decoder.decodeSingularBoolField(value: &self.drag)
      case 5: try decoder.decodeSingularBoolField(value: &self.dropOn)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.read != false {
      try visitor.visitSingularBoolField(value: self.read, fieldNumber: 1)
    }
    if self.edit != false {
      try visitor.visitSingularBoolField(value: self.edit, fieldNumber: 2)
    }
    if self.remove != false {
      try visitor.visitSingularBoolField(value: self.remove, fieldNumber: 3)
    }
    if self.drag != false {
      try visitor.visitSingularBoolField(value: self.drag, fieldNumber: 4)
    }
    if self.dropOn != false {
      try visitor.visitSingularBoolField(value: self.dropOn, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Restrictions, rhs: Anytype_Model_Block.Restrictions) -> Bool {
    if lhs.read != rhs.read {return false}
    if lhs.edit != rhs.edit {return false}
    if lhs.remove != rhs.remove {return false}
    if lhs.drag != rhs.drag {return false}
    if lhs.dropOn != rhs.dropOn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.protoMessageName + ".Content"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Content, rhs: Anytype_Model_Block.Content) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Layout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Layout"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.style)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.style != .row {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Content.Layout, rhs: Anytype_Model_Block.Content.Layout) -> Bool {
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Layout.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Row"),
    1: .same(proto: "Column"),
  ]
}

extension Anytype_Model_Block.Content.Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Link"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetBlockId"),
    2: .same(proto: "style"),
    3: .same(proto: "fields"),
    4: .same(proto: "isArchived"),
  ]

  fileprivate class _StorageClass {
    var _targetBlockID: String = String()
    var _style: Anytype_Model_Block.Content.Link.Style = .page
    var _fields: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _isArchived: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _targetBlockID = source._targetBlockID
      _style = source._style
      _fields = source._fields
      _isArchived = source._isArchived
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._targetBlockID)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._style)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._fields)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._isArchived)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._targetBlockID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._targetBlockID, fieldNumber: 1)
      }
      if _storage._style != .page {
        try visitor.visitSingularEnumField(value: _storage._style, fieldNumber: 2)
      }
      if let v = _storage._fields {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._isArchived != false {
        try visitor.visitSingularBoolField(value: _storage._isArchived, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Content.Link, rhs: Anytype_Model_Block.Content.Link) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._targetBlockID != rhs_storage._targetBlockID {return false}
        if _storage._style != rhs_storage._style {return false}
        if _storage._fields != rhs_storage._fields {return false}
        if _storage._isArchived != rhs_storage._isArchived {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Link.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Page"),
    1: .same(proto: "Dataview"),
    2: .same(proto: "Dashboard"),
  ]
}

extension Anytype_Model_Block.Content.Div: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Div"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.style)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.style != .line {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Content.Div, rhs: Anytype_Model_Block.Content.Div) -> Bool {
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Div.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Line"),
    1: .same(proto: "Dots"),
  ]
}

extension Anytype_Model_Block.Content.Bookmark: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Bookmark"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Content.Bookmark, rhs: Anytype_Model_Block.Content.Bookmark) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Icon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Icon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Content.Icon, rhs: Anytype_Model_Block.Content.Icon) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dashboard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Dashboard"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.style)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.style != .mainScreen {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Content.Dashboard, rhs: Anytype_Model_Block.Content.Dashboard) -> Bool {
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dashboard.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MainScreen"),
    1: .same(proto: "Archive"),
  ]
}

extension Anytype_Model_Block.Content.Dataview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Dataview"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Content.Dataview, rhs: Anytype_Model_Block.Content.Dataview) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Text"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "style"),
    3: .same(proto: "marks"),
    4: .same(proto: "checked"),
    5: .same(proto: "color"),
    6: .same(proto: "backgroundColor"),
  ]

  fileprivate class _StorageClass {
    var _text: String = String()
    var _style: Anytype_Model_Block.Content.Text.Style = .paragraph
    var _marks: Anytype_Model_Block.Content.Text.Marks? = nil
    var _checked: Bool = false
    var _color: String = String()
    var _backgroundColor: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _text = source._text
      _style = source._style
      _marks = source._marks
      _checked = source._checked
      _color = source._color
      _backgroundColor = source._backgroundColor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._text)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._style)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._marks)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._checked)
        case 5: try decoder.decodeSingularStringField(value: &_storage._color)
        case 6: try decoder.decodeSingularStringField(value: &_storage._backgroundColor)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._text.isEmpty {
        try visitor.visitSingularStringField(value: _storage._text, fieldNumber: 1)
      }
      if _storage._style != .paragraph {
        try visitor.visitSingularEnumField(value: _storage._style, fieldNumber: 2)
      }
      if let v = _storage._marks {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._checked != false {
        try visitor.visitSingularBoolField(value: _storage._checked, fieldNumber: 4)
      }
      if !_storage._color.isEmpty {
        try visitor.visitSingularStringField(value: _storage._color, fieldNumber: 5)
      }
      if !_storage._backgroundColor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._backgroundColor, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Content.Text, rhs: Anytype_Model_Block.Content.Text) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._text != rhs_storage._text {return false}
        if _storage._style != rhs_storage._style {return false}
        if _storage._marks != rhs_storage._marks {return false}
        if _storage._checked != rhs_storage._checked {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._backgroundColor != rhs_storage._backgroundColor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Text.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Paragraph"),
    1: .same(proto: "Header1"),
    2: .same(proto: "Header2"),
    3: .same(proto: "Header3"),
    4: .same(proto: "Header4"),
    5: .same(proto: "Quote"),
    6: .same(proto: "Code"),
    7: .same(proto: "Title"),
    8: .same(proto: "Checkbox"),
    9: .same(proto: "Marked"),
    10: .same(proto: "Numbered"),
    11: .same(proto: "Toggle"),
  ]
}

extension Anytype_Model_Block.Content.Text.Marks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.Content.Text.protoMessageName + ".Marks"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "marks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.marks)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.marks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Content.Text.Marks, rhs: Anytype_Model_Block.Content.Text.Marks) -> Bool {
    if lhs.marks != rhs.marks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Text.Mark: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.Content.Text.protoMessageName + ".Mark"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "range"),
    2: .same(proto: "type"),
    3: .same(proto: "param"),
  ]

  fileprivate class _StorageClass {
    var _range: Anytype_Model_Range? = nil
    var _type: Anytype_Model_Block.Content.Text.Mark.TypeEnum = .strikethrough
    var _param: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _range = source._range
      _type = source._type
      _param = source._param
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._range)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3: try decoder.decodeSingularStringField(value: &_storage._param)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._range {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._type != .strikethrough {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if !_storage._param.isEmpty {
        try visitor.visitSingularStringField(value: _storage._param, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Content.Text.Mark, rhs: Anytype_Model_Block.Content.Text.Mark) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._range != rhs_storage._range {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._param != rhs_storage._param {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Text.Mark.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Strikethrough"),
    1: .same(proto: "Keyboard"),
    2: .same(proto: "Italic"),
    3: .same(proto: "Bold"),
    4: .same(proto: "Underscored"),
    5: .same(proto: "Link"),
    6: .same(proto: "TextColor"),
    7: .same(proto: "BackgroundColor"),
  ]
}

extension Anytype_Model_Block.Content.File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".File"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "name"),
    3: .same(proto: "type"),
    4: .same(proto: "mime"),
    5: .same(proto: "size"),
    6: .same(proto: "addedAt"),
    7: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.hash)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularEnumField(value: &self.type)
      case 4: try decoder.decodeSingularStringField(value: &self.mime)
      case 5: try decoder.decodeSingularInt64Field(value: &self.size)
      case 6: try decoder.decodeSingularInt64Field(value: &self.addedAt)
      case 7: try decoder.decodeSingularEnumField(value: &self.state)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.type != .none {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if !self.mime.isEmpty {
      try visitor.visitSingularStringField(value: self.mime, fieldNumber: 4)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 5)
    }
    if self.addedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.addedAt, fieldNumber: 6)
    }
    if self.state != .empty {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Content.File, rhs: Anytype_Model_Block.Content.File) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.mime != rhs.mime {return false}
    if lhs.size != rhs.size {return false}
    if lhs.addedAt != rhs.addedAt {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.File.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "File"),
    2: .same(proto: "Image"),
    3: .same(proto: "Video"),
  ]
}

extension Anytype_Model_Block.Content.File.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Empty"),
    1: .same(proto: "Uploading"),
    2: .same(proto: "Done"),
    3: .same(proto: "Error"),
  ]
}

extension Anytype_Model_Block.Content.Page: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Page"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.style)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.style != .empty {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Block.Content.Page, rhs: Anytype_Model_Block.Content.Page) -> Bool {
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Page.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Empty"),
    1: .same(proto: "Task"),
    2: .same(proto: "Set"),
    3: .same(proto: "Breadcrumbs"),
  ]
}

extension Anytype_Model_BlockMetaOnly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockMetaOnly"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "fields"),
    5: .same(proto: "isArchived"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _fields: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _isArchived: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _fields = source._fields
      _isArchived = source._isArchived
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._fields)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._isArchived)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._fields {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._isArchived != false {
        try visitor.visitSingularBoolField(value: _storage._isArchived, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_BlockMetaOnly, rhs: Anytype_Model_BlockMetaOnly) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._fields != rhs_storage._fields {return false}
        if _storage._isArchived != rhs_storage._isArchived {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Range"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.from)
      case 2: try decoder.decodeSingularInt32Field(value: &self.to)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.from != 0 {
      try visitor.visitSingularInt32Field(value: self.from, fieldNumber: 1)
    }
    if self.to != 0 {
      try visitor.visitSingularInt32Field(value: self.to, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Range, rhs: Anytype_Model_Range) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Account"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "avatar"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: String = String()
    var _avatar: Anytype_Model_Account.Avatar? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _avatar = source._avatar
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._avatar)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if let v = _storage._avatar {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Account, rhs: Anytype_Model_Account) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._avatar != rhs_storage._avatar {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Account.Avatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Anytype_Model_Account.protoMessageName + ".Avatar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "color"),
  ]

  fileprivate class _StorageClass {
    var _avatar: Anytype_Model_Account.Avatar.OneOf_Avatar?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _avatar = source._avatar
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Anytype_Model_Block.Content.File?
          if let current = _storage._avatar {
            try decoder.handleConflictingOneOf()
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._avatar = .image(v)}
        case 2:
          if _storage._avatar != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._avatar = .color(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._avatar {
      case .image(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .color(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Anytype_Model_Account.Avatar, rhs: Anytype_Model_Account.Avatar) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._avatar != rhs_storage._avatar {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
