// DO NOT EDIT.
//
// Generated by the AnytypeSwiftCodegen.
//
// For information on using the generated types, please see the documentation:
//   https://github.com/anytypeio/anytype-swift-codegen

import Combine
import Foundation
import Lib
import SwiftProtobuf

enum Anytype_Middleware_Error {
  static let domain: String = "org.anytype.middleware.services"
}

extension Anytype_Rpc.ExternalDrop.Files {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibExternalDropFiles(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, dropTargetID: String, position: Anytype_Model_Block.Position, localFilePaths: [String], queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, dropTargetID: dropTargetID, position: position, localFilePaths: localFilePaths), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.ExternalDrop.Content {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibExternalDropContent(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, focusedBlockID: String, content: Data, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, focusedBlockID: focusedBlockID, content: content), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.ConvertChildrenToPages {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListConvertChildrenToPages(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockIds: [String], queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockIds: blockIds), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Move {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListMove(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockIds: [String], targetContextID: String, dropTargetID: String, position: Anytype_Model_Block.Position, queue: DispatchQueue? = nil) -> Future<
      Response, Error
    > {
      self.invoke(parameters: .init(contextID: contextID, blockIds: blockIds, targetContextID: targetContextID, dropTargetID: dropTargetID, position: position), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.MoveToNewPage {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListMoveToNewPage(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(
      contextID: String, blockIds: [String], details: SwiftProtobuf.Google_Protobuf_Struct, dropTargetID: String, position: Anytype_Model_Block.Position, queue: DispatchQueue? = nil
    ) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockIds: blockIds, details: details, dropTargetID: dropTargetID, position: position), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Duplicate {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListDuplicate(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, targetID: String, blockIds: [String], position: Anytype_Model_Block.Position, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, targetID: targetID, blockIds: blockIds, position: position), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Page.IsArchived {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetPageIsArchived(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockIds: [String], isArchived: Bool, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockIds: blockIds, isArchived: isArchived), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Style {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetTextStyle(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockIds: [String], style: Anytype_Model_Block.Content.Text.Style, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockIds: blockIds, style: style), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Color {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetTextColor(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockIds: [String], color: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockIds: blockIds, color: color), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Mark {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetTextMark(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockIds: [String], mark: Anytype_Model_Block.Content.Text.Mark, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockIds: blockIds, mark: mark), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.BackgroundColor {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetBackgroundColor(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockIds: [String], color: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockIds: blockIds, color: color), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Align {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetAlign(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockIds: [String], align: Anytype_Model_Block.Align, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockIds: blockIds, align: align), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Fields {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetFields(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockFields: [Anytype_Rpc.BlockList.Set.Fields.Request.BlockField], queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockFields: blockFields), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Div.Style {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetDivStyle(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockIds: [String], style: Anytype_Model_Block.Content.Div.Style, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockIds: blockIds, style: style), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Delete.Page {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListDeletePage(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(blockIds: [String], queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(blockIds: blockIds), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Replace {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockReplace(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, block: Anytype_Model_Block, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, block: block), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Split {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSplit(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, range: Anytype_Model_Range, style: Anytype_Model_Block.Content.Text.Style, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, range: range, style: style), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Merge {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockMerge(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, firstBlockID: String, secondBlockID: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, firstBlockID: firstBlockID, secondBlockID: secondBlockID), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Copy {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCopy(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blocks: [Anytype_Model_Block], selectedTextRange: Anytype_Model_Range, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blocks: blocks, selectedTextRange: selectedTextRange), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Paste {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockPaste(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(
      contextID: String, focusedBlockID: String, selectedTextRange: Anytype_Model_Range, selectedBlockIds: [String], isPartOfBlock: Bool, textSlot: String, htmlSlot: String,
      anySlot: [Anytype_Model_Block], queue: DispatchQueue? = nil
    ) -> Future<Response, Error> {
      self.invoke(
        parameters: .init(
          contextID: contextID, focusedBlockID: focusedBlockID, selectedTextRange: selectedTextRange, selectedBlockIds: selectedBlockIds, isPartOfBlock: isPartOfBlock, textSlot: textSlot,
          htmlSlot: htmlSlot, anySlot: anySlot), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Cut {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCut(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blocks: [Anytype_Model_Block], selectedTextRange: Anytype_Model_Range, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blocks: blocks, selectedTextRange: selectedTextRange), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.ImportMarkdown {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockImportMarkdown(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, importPath: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, importPath: importPath), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Export {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockExport(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blocks: [Anytype_Model_Block], queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blocks: blocks), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Upload {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockUpload(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, filePath: String, url: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, filePath: filePath, url: url), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Download {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockDownload(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Fields {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetFields(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, fields: SwiftProtobuf.Google_Protobuf_Struct, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, fields: fields), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Details {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetDetails(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, details: [Anytype_Rpc.Block.Set.Details.Detail], queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, details: details), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Restrictions {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetRestrictions(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, restrictions: Anytype_Model_Block.Restrictions, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, restrictions: restrictions), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Page.IsArchived {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetPageIsArchived(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, isArchived: Bool, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, isArchived: isArchived), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Text.Text {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetTextText(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, text: String, marks: Anytype_Model_Block.Content.Text.Marks, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, text: text, marks: marks), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Text.Color {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetTextColor(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, color: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, color: color), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Text.Style {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetTextStyle(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, style: Anytype_Model_Block.Content.Text.Style, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, style: style), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Text.Checked {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetTextChecked(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, checked: Bool, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, checked: checked), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.File.Name {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetFileName(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, name: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, name: name), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Image.Name {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetImageName(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, name: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, name: name), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Image.Width {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetImageWidth(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, width: Int32, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, width: width), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Video.Name {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetVideoName(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, name: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, name: name), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Video.Width {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetVideoWidth(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, width: Int32, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, width: width), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Link.TargetBlockId {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetLinkTargetBlockId(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, targetBlockID: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, targetBlockID: targetBlockID), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Dataview.View {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetDataviewView(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, viewID: String, view: Anytype_Model_Block.Content.Dataview.View, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, viewID: viewID, view: view), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Dataview.ActiveView {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetDataviewActiveView(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, viewID: String, offset: UInt32, limit: UInt32, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, viewID: viewID, offset: offset, limit: limit), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Bookmark.Fetch {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockBookmarkFetch(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, url: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, url: url), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Bookmark.CreateAndFetch {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockBookmarkCreateAndFetch(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, targetID: String, position: Anytype_Model_Block.Position, url: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, targetID: targetID, position: position, url: url), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.File.CreateAndUpload {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockFileCreateAndUpload(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(
      contextID: String, targetID: String, position: Anytype_Model_Block.Position, url: String, localPath: String, fileType: Anytype_Model_Block.Content.File.TypeEnum, queue: DispatchQueue? = nil
    ) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, targetID: targetID, position: position, url: url, localPath: localPath, fileType: fileType), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Get.Marks {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockGetMarks(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, range: Anytype_Model_Range, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, range: range), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Undo {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockUndo(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Redo {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockRedo(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Open {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockOpen(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.GetPublicWebURL {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockGetPublicWebURL(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(blockID: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(blockID: blockID), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.OpenBreadcrumbs {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockOpenBreadcrumbs(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.SetBreadcrumbs {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetBreadcrumbs(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(breadcrumbsID: String, ids: [String], queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(breadcrumbsID: breadcrumbsID, ids: ids), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Create {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCreate(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, targetID: String, block: Anytype_Model_Block, position: Anytype_Model_Block.Position, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, targetID: targetID, block: block, position: position), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Create.Dataview.View {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCreateDataviewView(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, view: Anytype_Model_Block.Content.Dataview.View, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, view: view), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.CreatePage {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCreatePage(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, targetID: String, details: SwiftProtobuf.Google_Protobuf_Struct, position: Anytype_Model_Block.Position, queue: DispatchQueue? = nil) -> Future<
      Response, Error
    > {
      self.invoke(parameters: .init(contextID: contextID, targetID: targetID, details: details, position: position), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Unlink {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockUnlink(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockIds: [String], queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockIds: blockIds), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Delete.Dataview.View {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockDeleteDataviewView(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, viewID: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID, viewID: viewID), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Close {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockClose(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(contextID: String, blockID: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(contextID: contextID, blockID: blockID), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Wallet.Create {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibWalletCreate(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(rootPath: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(rootPath: rootPath), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Wallet.Recover {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibWalletRecover(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(rootPath: String, mnemonic: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(rootPath: rootPath, mnemonic: mnemonic), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Account.Create {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibAccountCreate(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(name: String, avatar: Anytype_Rpc.Account.Create.Request.OneOf_Avatar?, alphaInviteCode: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(name: name, avatar: avatar, alphaInviteCode: alphaInviteCode), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Account.Recover {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibAccountRecover(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Account.Select {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibAccountSelect(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(id: String, rootPath: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(id: id, rootPath: rootPath), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Account.Stop {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibAccountStop(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(removeData: Bool, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(removeData: removeData), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Log.Send {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibLogSend(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(message: String, level: Anytype_Rpc.Log.Send.Request.Level, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(message: message, level: level), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Version.Get {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibVersionGet(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Ipfs.Image.Get.Blob {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibImageGetBlob(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(hash: String, wantWidth: Int32, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(hash: hash, wantWidth: wantWidth), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Shutdown {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibShutdown(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Config.Get {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibConfigGet(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Ping {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibPing(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(index: Int32, numberOfEventsToSend: Int32, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(index: index, numberOfEventsToSend: numberOfEventsToSend), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Process.Cancel {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibProcessCancel(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(id: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(id: id), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.LinkPreview {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibLinkPreview(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(url: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(url: url), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.UploadFile {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibUploadFile(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(url: String, localPath: String, type: Anytype_Model_Block.Content.File.TypeEnum, disableEncryption: Bool, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(url: url, localPath: localPath, type: type, disableEncryption: disableEncryption), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Navigation.ListPages {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibNavigationListPages(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Navigation.GetPageInfoWithLinks {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibNavigationGetPageInfoWithLinks(data) }
  }

  enum Service {
    public typealias RequestParameters = Request
    private static func request(_ parameters: RequestParameters) -> Request {
      parameters
    }
    public static func invoke(pageID: String, queue: DispatchQueue? = nil) -> Future<Response, Error> {
      self.invoke(parameters: .init(pageID: pageID), on: queue)
    }
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
      .init { promise in
        if let queue = queue {
          queue.async {
            promise(self.result(self.request(parameters)))
          }
        } else {
          promise(self.result(self.request(parameters)))
        }
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}
