// DO NOT EDIT.
//
// Generated by the AnytypeSwiftCodegen.
//
// For information on using the generated types, please see the documentation:
//   https://github.com/anytypeio/anytype-swift-codegen

import Combine
import Foundation
import Lib
import SwiftProtobuf

enum Anytype_Middleware_Error {
  static let domain: String = "org.anytype.middleware.services"
}

extension Anytype_Rpc.ExternalDrop.Files {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibExternalDropFiles(data) }
  }

  enum Service {
    public static func invoke(contextID: String, dropTargetID: String, position: Anytype_Model_Block.Position, localFilePaths: [String]) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, dropTargetID: dropTargetID, position: position, localFilePaths: localFilePaths))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.ExternalDrop.Content {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibExternalDropContent(data) }
  }

  enum Service {
    public static func invoke(contextID: String, focusedBlockID: String, content: Data) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, focusedBlockID: focusedBlockID, content: content))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.ConvertChildrenToPages {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListConvertChildrenToPages(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String]) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockIds: blockIds))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Move {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListMove(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String], targetContextID: String, dropTargetID: String, position: Anytype_Model_Block.Position) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockIds: blockIds, targetContextID: targetContextID, dropTargetID: dropTargetID, position: position))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.MoveToNewPage {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListMoveToNewPage(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String], details: SwiftProtobuf.Google_Protobuf_Struct, dropTargetID: String, position: Anytype_Model_Block.Position) -> Future<
      Response, Error
    > {
      .init { promise in promise(self.result(.init(contextID: contextID, blockIds: blockIds, details: details, dropTargetID: dropTargetID, position: position))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Duplicate {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListDuplicate(data) }
  }

  enum Service {
    public static func invoke(contextID: String, targetID: String, blockIds: [String], position: Anytype_Model_Block.Position) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, targetID: targetID, blockIds: blockIds, position: position))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Page.IsArchived {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetPageIsArchived(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String], isArchived: Bool) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockIds: blockIds, isArchived: isArchived))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Style {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetTextStyle(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String], style: Anytype_Model_Block.Content.Text.Style) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockIds: blockIds, style: style))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Color {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetTextColor(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String], color: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockIds: blockIds, color: color))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Mark {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetTextMark(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String], mark: Anytype_Model_Block.Content.Text.Mark) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockIds: blockIds, mark: mark))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.BackgroundColor {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetBackgroundColor(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String], color: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockIds: blockIds, color: color))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Align {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetAlign(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String], align: Anytype_Model_Block.Align) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockIds: blockIds, align: align))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Fields {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetFields(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockFields: [Anytype_Rpc.BlockList.Set.Fields.Request.BlockField]) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockFields: blockFields))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Set.Div.Style {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetDivStyle(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String], style: Anytype_Model_Block.Content.Div.Style) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockIds: blockIds, style: style))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.BlockList.Delete.Page {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListDeletePage(data) }
  }

  enum Service {
    public static func invoke(blockIds: [String]) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(blockIds: blockIds))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Replace {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockReplace(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, block: Anytype_Model_Block) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, block: block))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Split {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSplit(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, range: Anytype_Model_Range, style: Anytype_Model_Block.Content.Text.Style) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, range: range, style: style))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Merge {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockMerge(data) }
  }

  enum Service {
    public static func invoke(contextID: String, firstBlockID: String, secondBlockID: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, firstBlockID: firstBlockID, secondBlockID: secondBlockID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Copy {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCopy(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blocks: [Anytype_Model_Block], selectedTextRange: Anytype_Model_Range) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blocks: blocks, selectedTextRange: selectedTextRange))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Paste {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockPaste(data) }
  }

  enum Service {
    public static func invoke(
      contextID: String, focusedBlockID: String, selectedTextRange: Anytype_Model_Range, selectedBlockIds: [String], isPartOfBlock: Bool, textSlot: String, htmlSlot: String,
      anySlot: [Anytype_Model_Block]
    ) -> Future<Response, Error> {
      .init { promise in
        promise(
          self.result(
            .init(
              contextID: contextID, focusedBlockID: focusedBlockID, selectedTextRange: selectedTextRange, selectedBlockIds: selectedBlockIds, isPartOfBlock: isPartOfBlock, textSlot: textSlot,
              htmlSlot: htmlSlot, anySlot: anySlot)))
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Cut {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCut(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blocks: [Anytype_Model_Block], selectedTextRange: Anytype_Model_Range) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blocks: blocks, selectedTextRange: selectedTextRange))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.ImportMarkdown {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockImportMarkdown(data) }
  }

  enum Service {
    public static func invoke(contextID: String, importPath: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, importPath: importPath))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Export {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockExport(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blocks: [Anytype_Model_Block]) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blocks: blocks))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Upload {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockUpload(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, filePath: String, url: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, filePath: filePath, url: url))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Download {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockDownload(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Fields {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetFields(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, fields: SwiftProtobuf.Google_Protobuf_Struct) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, fields: fields))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Details {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetDetails(data) }
  }

  enum Service {
    typealias RequestParameters = (contextID: String, details: [Anytype_Rpc.Block.Set.Details.Detail])
    
    private static func request(_ parameters: RequestParameters) -> Request {
        .init(contextID: parameters.contextID, details: parameters.details)
    }
    
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
        .init { promise in
            if let queue = queue {
                queue.async {
                    promise(self.result(self.request(parameters)))
                }
            }
            else {
                promise(self.result(self.request(parameters)))
            }
        }
    }
    public static func invoke(_ parameters: RequestParameters, queue: DispatchQueue? = nil) -> Future<Response, Error> {
        self.invoke(parameters: parameters, on: queue)
    }

    private static func invoke(contextID: String, details: [Anytype_Rpc.Block.Set.Details.Detail]) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, details: details))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Restrictions {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetRestrictions(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, restrictions: Anytype_Model_Block.Restrictions) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, restrictions: restrictions))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Page.IsArchived {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetPageIsArchived(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, isArchived: Bool) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, isArchived: isArchived))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Text.Text {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetTextText(data) }
  }

  enum Service {
    typealias RequestParameters = (contextID: String, blockID: String, text: String, marks: Anytype_Model_Block.Content.Text.Marks)
    
    private static func invoke(parameters: RequestParameters, on queue: DispatchQueue?) -> Future<Response, Error> {
        .init { promise in
            if let queue = queue {
                queue.async {
                    promise(self.result(.init(contextID: parameters.contextID, blockID: parameters.blockID, text: parameters.text, marks: parameters.marks)))
                }
            }
            else {
                promise(self.result(.init(contextID: parameters.contextID, blockID: parameters.blockID, text: parameters.text, marks: parameters.marks)))
            }
        }
    }
    public static func invoke(_ parameters: RequestParameters, queue: DispatchQueue? = nil) -> Future<Response, Error> {
        self.invoke(parameters: parameters, on: queue)
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Text.Color {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetTextColor(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, color: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, color: color))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Text.Style {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetTextStyle(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, style: Anytype_Model_Block.Content.Text.Style) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, style: style))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Text.Checked {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetTextChecked(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, checked: Bool) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, checked: checked))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.File.Name {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetFileName(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, name: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, name: name))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Image.Name {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetImageName(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, name: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, name: name))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Image.Width {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetImageWidth(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, width: Int32) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, width: width))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Video.Name {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetVideoName(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, name: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, name: name))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Video.Width {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetVideoWidth(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, width: Int32) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, width: width))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Link.TargetBlockId {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetLinkTargetBlockId(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, targetBlockID: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, targetBlockID: targetBlockID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Dataview.View {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetDataviewView(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, viewID: String, view: Anytype_Model_Block.Content.Dataview.View) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, viewID: viewID, view: view))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Set.Dataview.ActiveView {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetDataviewActiveView(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, viewID: String, offset: UInt32, limit: UInt32) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, viewID: viewID, offset: offset, limit: limit))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Bookmark.Fetch {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockBookmarkFetch(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, url: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, url: url))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Bookmark.CreateAndFetch {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockBookmarkCreateAndFetch(data) }
  }

  enum Service {
    public static func invoke(contextID: String, targetID: String, position: Anytype_Model_Block.Position, url: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, targetID: targetID, position: position, url: url))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.File.CreateAndUpload {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockFileCreateAndUpload(data) }
  }

  enum Service {
    public static func invoke(contextID: String, targetID: String, position: Anytype_Model_Block.Position, url: String, localPath: String, fileType: Anytype_Model_Block.Content.File.TypeEnum)
      -> Future<Response, Error>
    {
      .init { promise in promise(self.result(.init(contextID: contextID, targetID: targetID, position: position, url: url, localPath: localPath, fileType: fileType))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Get.Marks {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockGetMarks(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, range: Anytype_Model_Range) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, range: range))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Undo {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockUndo(data) }
  }

  enum Service {
    public static func invoke(contextID: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Redo {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockRedo(data) }
  }

  enum Service {
    public static func invoke(contextID: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Open {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockOpen(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.GetPublicWebURL {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockGetPublicWebURL(data) }
  }

  enum Service {
    public static func invoke(blockID: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(blockID: blockID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.OpenBreadcrumbs {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockOpenBreadcrumbs(data) }
  }

  enum Service {
    public static func invoke(contextID: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.SetBreadcrumbs {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetBreadcrumbs(data) }
  }

  enum Service {
    public static func invoke(breadcrumbsID: String, ids: [String]) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(breadcrumbsID: breadcrumbsID, ids: ids))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Create {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCreate(data) }
  }

  enum Service {
    public static func invoke(contextID: String, targetID: String, block: Anytype_Model_Block, position: Anytype_Model_Block.Position) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, targetID: targetID, block: block, position: position))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Create.Dataview.View {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCreateDataviewView(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, view: Anytype_Model_Block.Content.Dataview.View) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, view: view))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.CreatePage {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCreatePage(data) }
  }

  enum Service {
    public static func invoke(contextID: String, targetID: String, details: SwiftProtobuf.Google_Protobuf_Struct, position: Anytype_Model_Block.Position) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, targetID: targetID, details: details, position: position))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Unlink {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockUnlink(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String]) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockIds: blockIds))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Delete.Dataview.View {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockDeleteDataviewView(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, viewID: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID, viewID: viewID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Block.Close {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockClose(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(contextID: contextID, blockID: blockID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Wallet.Create {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibWalletCreate(data) }
  }

  enum Service {
    public static func invoke(rootPath: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(rootPath: rootPath))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Wallet.Recover {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibWalletRecover(data) }
  }

  enum Service {
    public static func invoke(rootPath: String, mnemonic: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(rootPath: rootPath, mnemonic: mnemonic))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Account.Create {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibAccountCreate(data) }
  }

  enum Service {
    public static func invoke(name: String, avatar: Anytype_Rpc.Account.Create.Request.OneOf_Avatar?, alphaInviteCode: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(name: name, avatar: avatar, alphaInviteCode: alphaInviteCode))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Account.Recover {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibAccountRecover(data) }
  }

  enum Service {
    public static func invoke() -> Future<Response, Error> {
      .init { promise in promise(self.result(.init())) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Account.Select {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibAccountSelect(data) }
  }

  enum Service {
    public static func invoke(id: String, rootPath: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(id: id, rootPath: rootPath))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Account.Stop {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibAccountStop(data) }
  }

  enum Service {
    public static func invoke(removeData: Bool) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(removeData: removeData))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Log.Send {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibLogSend(data) }
  }

  enum Service {
    public static func invoke(message: String, level: Anytype_Rpc.Log.Send.Request.Level) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(message: message, level: level))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Version.Get {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibVersionGet(data) }
  }

  enum Service {
    public static func invoke() -> Future<Response, Error> {
      .init { promise in promise(self.result(.init())) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Ipfs.Image.Get.Blob {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibImageGetBlob(data) }
  }

  enum Service {
    public static func invoke(hash: String, wantWidth: Int32) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(hash: hash, wantWidth: wantWidth))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Shutdown {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibShutdown(data) }
  }

  enum Service {
    public static func invoke() -> Future<Response, Error> {
      .init { promise in promise(self.result(.init())) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Config.Get {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibConfigGet(data) }
  }

  enum Service {
    public static func invoke() -> Future<Response, Error> {
      .init { promise in promise(self.result(.init())) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Ping {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibPing(data) }
  }

  enum Service {
    public static func invoke(index: Int32, numberOfEventsToSend: Int32) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(index: index, numberOfEventsToSend: numberOfEventsToSend))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Process.Cancel {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibProcessCancel(data) }
  }

  enum Service {
    public static func invoke(id: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(id: id))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.LinkPreview {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibLinkPreview(data) }
  }

  enum Service {
    public static func invoke(url: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(url: url))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.UploadFile {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibUploadFile(data) }
  }

  enum Service {
    public static func invoke(url: String, localPath: String, type: Anytype_Model_Block.Content.File.TypeEnum, disableEncryption: Bool) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(url: url, localPath: localPath, type: type, disableEncryption: disableEncryption))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Navigation.ListPages {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibNavigationListPages(data) }
  }

  enum Service {
    public static func invoke() -> Future<Response, Error> {
      .init { promise in promise(self.result(.init())) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

extension Anytype_Rpc.Navigation.GetPageInfoWithLinks {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibNavigationGetPageInfoWithLinks(data) }
  }

  enum Service {
    public static func invoke(pageID: String) -> Future<Response, Error> {
      .init { promise in promise(self.result(.init(pageID: pageID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        let domain = Anytype_Middleware_Error.domain
        let code = result.error.code.rawValue
        let description = result.error.description_p
        return .failure(NSError(domain: domain, code: code, userInfo: [NSLocalizedDescriptionKey: description]))
      } else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}
