// DO NOT EDIT.
//
// Generated by the AnytypeSwiftCodegen.
//
// For information on using the generated types, please see the documentation:
//   https://github.com/anytypeio/anytype-swift-codegen

import Foundation
import SwiftProtobuf
import Combine
import Lib

internal extension Anytype_Rpc.ExternalDrop.Files {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibExternalDropFiles(data) }
  }

  enum Service {
    public static func invoke(contextID: String, focusedBlockID: String, localFilePaths: [String]) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, focusedBlockID: focusedBlockID, localFilePaths: localFilePaths))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.ExternalDrop.Content {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibExternalDropContent(data) }
  }

  enum Service {
    public static func invoke(contextID: String, focusedBlockID: String, content: Data) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, focusedBlockID: focusedBlockID, content: content))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.BlockList.Move {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListMove(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String], targetContextID: String, dropTargetID: String, position: Anytype_Model_Block.Position) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockIds: blockIds, targetContextID: targetContextID, dropTargetID: dropTargetID, position: position))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.BlockList.Duplicate {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListDuplicate(data) }
  }

  enum Service {
    public static func invoke(contextID: String, targetID: String, blockIds: [String], position: Anytype_Model_Block.Position) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, targetID: targetID, blockIds: blockIds, position: position))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.BlockList.Set.Text.Style {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetTextStyle(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String], style: Anytype_Model_Block.Content.Text.Style) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockIds: blockIds, style: style))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.BlockList.Set.Text.Color {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetTextColor(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String], color: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockIds: blockIds, color: color))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.BlockList.Set.Text.BackgroundColor {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetTextBackgroundColor(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String], color: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockIds: blockIds, color: color))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.BlockList.Set.Fields {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockListSetFields(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockFields: [Anytype_Rpc.BlockList.Set.Fields.Request.BlockField]) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockFields: blockFields))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Replace {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockReplace(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, block: Anytype_Model_Block) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, block: block))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Split {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSplit(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, cursorPosition: Int32) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, cursorPosition: cursorPosition))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Merge {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockMerge(data) }
  }

  enum Service {
    public static func invoke(contextID: String, firstBlockID: String, secondBlockID: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, firstBlockID: firstBlockID, secondBlockID: secondBlockID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Copy {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCopy(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String]) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockIds: blockIds))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Paste {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockPaste(data) }
  }

  enum Service {
    public static func invoke(
      contextID: String,
      focusedBlockID: String,
      selectedTextRange: Anytype_Model_Range,
      selectedBlockIds: [String],
      textSlot: String,
      htmlSlot: String,
      anySlot: [Anytype_Model_Block]
    ) -> Future<Response, Error> {
      .init { completion in
        completion(
          self.result(
            .init(
              contextID: contextID,
              focusedBlockID: focusedBlockID,
              selectedTextRange: selectedTextRange,
              selectedBlockIds: selectedBlockIds,
              textSlot: textSlot,
              htmlSlot: htmlSlot,
              anySlot: anySlot
            )
          )
        )
      }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Upload {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockUpload(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, filePath: String, url: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, filePath: filePath, url: url))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Download {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockDownload(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.Fields {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetFields(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, fields: SwiftProtobuf.Google_Protobuf_Struct) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, fields: fields))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.Restrictions {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetRestrictions(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, restrictions: Anytype_Model_Block.Restrictions) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, restrictions: restrictions))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.Text.Text {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetTextText(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, text: String, marks: Anytype_Model_Block.Content.Text.Marks) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, text: text, marks: marks))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.Text.Color {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetTextColor(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, color: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, color: color))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.Text.BackgroundColor {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetTextBackgroundColor(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, color: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, color: color))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.Text.Style {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetTextStyle(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, style: Anytype_Model_Block.Content.Text.Style) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, style: style))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.Text.Checked {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetTextChecked(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, checked: Bool) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, checked: checked))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.File.Name {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetFileName(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, name: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, name: name))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.Image.Name {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetImageName(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, name: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, name: name))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.Image.Width {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetImageWidth(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, width: Int32) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, width: width))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.Video.Name {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetVideoName(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, name: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, name: name))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.Video.Width {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetVideoWidth(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, width: Int32) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, width: width))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.Icon.Name {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetIconName(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, name: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, name: name))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Set.Link.TargetBlockId {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockSetLinkTargetBlockId(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, targetBlockID: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, targetBlockID: targetBlockID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Get.Marks {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockGetMarks(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, range: Anytype_Model_Range) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, range: range))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Undo {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockUndo(data) }
  }

  enum Service {
    public static func invoke(contextID: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Redo {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockRedo(data) }
  }

  enum Service {
    public static func invoke(contextID: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Open {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockOpen(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String, breadcrumbsIds: [String]) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID, breadcrumbsIds: breadcrumbsIds))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.OpenBreadcrumbs {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockOpenBreadcrumbs(data) }
  }

  enum Service {
    public static func invoke(contextID: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.CutBreadcrumbs {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCutBreadcrumbs(data) }
  }

  enum Service {
    public static func invoke(breadcrumbsID: String, index: Int32) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(breadcrumbsID: breadcrumbsID, index: index))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Create {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCreate(data) }
  }

  enum Service {
    public static func invoke(contextID: String, targetID: String, block: Anytype_Model_Block, position: Anytype_Model_Block.Position) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, targetID: targetID, block: block, position: position))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.CreatePage {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockCreatePage(data) }
  }

  enum Service {
    public static func invoke(contextID: String, targetID: String, block: Anytype_Model_Block, position: Anytype_Model_Block.Position) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, targetID: targetID, block: block, position: position))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Unlink {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockUnlink(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockIds: [String]) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockIds: blockIds))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Block.Close {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibBlockClose(data) }
  }

  enum Service {
    public static func invoke(contextID: String, blockID: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(contextID: contextID, blockID: blockID))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Wallet.Create {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibWalletCreate(data) }
  }

  enum Service {
    public static func invoke(rootPath: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(rootPath: rootPath))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Wallet.Recover {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibWalletRecover(data) }
  }

  enum Service {
    public static func invoke(rootPath: String, mnemonic: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(rootPath: rootPath, mnemonic: mnemonic))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Account.Create {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibAccountCreate(data) }
  }

  enum Service {
    public static func invoke(name: String, avatar: Anytype_Rpc.Account.Create.Request.OneOf_Avatar?) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(name: name, avatar: avatar))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Account.Recover {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibAccountRecover(data) }
  }

  enum Service {
    public static func invoke() -> Future<Response, Error> {
      .init { completion in completion(self.result(.init())) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Account.Select {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibAccountSelect(data) }
  }

  enum Service {
    public static func invoke(id: String, rootPath: String) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(id: id, rootPath: rootPath))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Account.Stop {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibAccountStop(data) }
  }

  enum Service {
    public static func invoke(removeData: Bool) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(removeData: removeData))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Log.Send {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibLogSend(data) }
  }

  enum Service {
    public static func invoke(message: String, level: Anytype_Rpc.Log.Send.Request.Level) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(message: message, level: level))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Version.Get {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibVersionGet(data) }
  }

  enum Service {
    public static func invoke() -> Future<Response, Error> {
      .init { completion in completion(self.result(.init())) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Ipfs.Image.Get.Blob {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibImageGetBlob(data) }
  }

  enum Service {
    public static func invoke(hash: String, wantWidth: Int32) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(hash: hash, wantWidth: wantWidth))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Config.Get {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibConfigGet(data) }
  }

  enum Service {
    public static func invoke() -> Future<Response, Error> {
      .init { completion in completion(self.result(.init())) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}

internal extension Anytype_Rpc.Ping {
  private struct Invocation {
    static func invoke(_ data: Data?) -> Data? { Lib.LibPing(data) }
  }

  enum Service {
    public static func invoke(index: Int32, numberOfEventsToSend: Int32) -> Future<Response, Error> {
      .init { completion in completion(self.result(.init(index: index, numberOfEventsToSend: numberOfEventsToSend))) }
    }
    private static func result(_ request: Request) -> Result<Response, Error> {
      guard let result = self.invoke(request) else {
        // get first Not Null (not equal 0) case.
        return .failure(Response.Error(code: .unknownError, description_p: "Unknown error during parsing"))
      }
      // get first zero case.
      if result.error.code != .null {
        return .failure(result.error)
      }
      else {
        return .success(result)
      }
    }
    private static func invoke(_ request: Request) -> Response? {
      Invocation.invoke(try? request.serializedData()).flatMap {
        try? Response(serializedData: $0)
      }
    }
  }
}
